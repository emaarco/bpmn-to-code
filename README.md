> üöß **This plugin is currently in a beta-version.
> Feel free to test it and provide feedback! :)**

# üöÄ bpmn-to-code

bpmn-to-code is a Maven and Gradle plugin designed to simplify process automation.
Its vision is to foster clean & robust solutions for BPMN-based process automation.
Therefore, it aims to provide a range of features ‚Äî
such as generating API definition files from BPMN process models ‚Äî
to reduce manual effort, simplify testing, promote the creation of clean process models,
and ensure consistency between your BPMN model and your code.

## **ü§©** What it can do for you

**Streamlined Process Automation**

Say goodbye to the tedious task of manually referencing BPMN elements. bpmn-to-code automatically extracts key
details‚Äîlike element IDs, messages, and worker types‚Äîand generates a lightweight ‚Äú**Process API**‚Äù that keeps your
process models and code in sync.

**Java & Kotlin Code Generation**

Whether you‚Äôre developing in **Java** or **Kotlin**, our plugin creates ready-to-use API definitions that integrate
seamlessly with your testing frameworks, messaging systems, or any other automation logic.

**Engine Agnostic & Extensible**

Currently, bpmn-to-code supports both **Camunda** 7 and **Zeebe**. Built with extensibility in mind, it is designed so
that adding support for additional process engines is straightforward‚Äîif there is enough demand.

**Styleguide Validation** (üöß)

Looking ahead, I‚Äôm planing a styleguide validation feature. Much like a linter for code, it will analyze your BPMN
models against your custom style guide - ensuring that element IDs, message names, and task types adhere to predefined
patterns and naming conventions. This will help maintain designs that are as clean and consistent as your code.

## üìñ Story behind the plugin

If you want to learn more about the vision & story behind the plugin ‚Äî
and the problems it aims to solve as well as the advantages it can bring ‚Äî
check out the following posts:

- [üá¨üáß Simplifying process automation with bpmn-to-code](https://medium.com/miragon/simplifying-process-automation-with-bpmn-to-code-from-bpmn-models-to-process-apis-216adafeb0ac)
- [üá©üá™ Mit bpmn-to-code ein deine Prozesse & Code in Einklang bringen](https://www.miragon.io/blog/mit-bpmn-to-code-deine-prozesse-and-code-in-einklang-bringen/)

## üí° Process-API generation in action

The key feature of bpmn-to-code is generating a lightweight ‚ÄúProcess API‚Äù for your BPMN models.
Let‚Äôs say you have a newsletter subscription workflow (BPMN) that looks like this:

<img src="docs/example-process.png" alt="Example Process" width="800"/>

After running bpmn-to-code, you‚Äôll have a Kotlin (or Java) file that programmatically references your process model. For
example:

```kotlin
// Generated by bpmn-to-code
@file:Suppress("unused")

package de.emaarco.example

import kotlin.String
import kotlin.Suppress

object NewsletterSubscriptionProcessApiV1 {
    const val PROCESS_ID: String = "newsletterSubscription"

    object Elements {
        const val TIMER_EVERY_DAY: String = "Timer_EveryDay"
        const val TIMER_AFTER_3_DAYS: String = "Timer_After3Days"
        const val ERROR_EVENT_INVALID_MAIL: String = "ErrorEvent_InvalidMail"
        const val ACTIVITY_CONFIRM_REGISTRATION: String = "Activity_ConfirmRegistration"
        const val SUB_PROCESS_CONFIRMATION: String = "SubProcess_Confirmation"
        const val END_EVENT_REGISTRATION_ABORTED: String = "EndEvent_RegistrationAborted"
        const val END_EVENT_SUBSCRIPTION_CONFIRMED: String = "EndEvent_SubscriptionConfirmed"
        const val END_EVENT_REGISTRATION_COMPLETED: String = "EndEvent_RegistrationCompleted"
        const val END_EVENT_REGISTRATION_NOT_POSSIBLE: String = "EndEvent_RegistrationNotPossible"
        const val ACTIVITY_ABORT_REGISTRATION: String = "Activity_AbortRegistration"
        const val ACTIVITY_SEND_WELCOME_MAIL: String = "Activity_SendWelcomeMail"
        const val ACTIVITY_SEND_CONFIRMATION_MAIL: String = "Activity_SendConfirmationMail"
        const val START_EVENT_SUBMIT_REGISTRATION_FORM: String = "StartEvent_SubmitRegistrationForm"
        const val START_EVENT_REQUEST_RECEIVED: String = "StartEvent_RequestReceived"
    }

    object Messages {
        const val MESSAGE_FORM_SUBMITTED: String = "Message_FormSubmitted"
        const val MESSAGE_SUBSCRIPTION_CONFIRMED: String = "Message_SubscriptionConfirmed"
    }

    object TaskTypes {
        const val END_EVENT_REGISTRATION_COMPLETED: String = "newsletter.registrationCompleted"
        const val ACTIVITY_ABORT_REGISTRATION: String = "newsletter.abortRegistration"
        const val ACTIVITY_SEND_WELCOME_MAIL: String = "newsletter.sendWelcomeMail"
        const val ACTIVITY_SEND_CONFIRMATION_MAIL: String = "newsletter.sendConfirmationMail"
    }

    object Timers {
        val TIMER_EVERY_DAY: BpmnTimer = BpmnTimer("Duration", "PT1M")
        val TIMER_AFTER_3_DAYS: BpmnTimer = BpmnTimer("Duration", "PT2M30S")

        data class BpmnTimer(
            val type: String,
            val timerValue: String,
        )
    }

    object Errors {
        val ERROR_INVALID_MAIL: BpmnError = BpmnError("Error_InvalidMail", "500")

        data class BpmnError(
            val name: String,
            val code: String,
        )
    }

    object Signals {
        const val SIGNAL_REGISTRATION_NOT_POSSIBLE: String = "Signal_RegistrationNotPossible"
    }

    object Variables {
        const val SUBSCRIPTION_ID: String = "subscriptionId"
    }
}
```

All you need is a simple Gradle task configuration that specifies **where** your BPMN models reside,
**where** to output the generated API files, **which** language (Java or Kotlin) to generate,
and **which** process engine your models target (e.g., Camunda 7 or Zeebe):

```kotlin
tasks.named("generateBpmnModelApi", GenerateBpmnModelsTask::class) {
    baseDir = projectDir.toString()
    filePattern = "src/main/resources/**/*.bpmn"
    outputFolderPath = "$projectDir/src/main/kotlin"
    packagePath = "de.emaarco.example"
    outputLanguage = OutputLanguage.KOTLIN
    processEngine = ProcessEngine.ZEEBE
    useVersioning = false
}
```

Once configured, **bpmn-to-code** automatically picks up your BPMN files and generates convenient,
type-safe references you can use throughout your application‚Äîbe it for testing, messaging,
or worker definitions.

## üì¶ Structure

bpmn-to-code is available for both Gradle and Maven.
For detailed installation and configuration instructions,
please refer to the respective module README's:

- [bpmn-to-code-gradle](bpmn-to-code-gradle/README.md): Gradle plugin integration for
  projects using Gradle.
- [bpmn-to-code-maven](bpmn-to-code-maven/README.md): Maven plugin integration for
  projects using Maven.
- [bpmn-to-code-core](bpmn-to-code-core): Contains the core logic for parsing BPMN files and generating the API
  representation.
- [examples](examples): Contains gradle- & maven-example projects demonstrating how to use the plugin. They are not part
  of the
  gradle-monorepo. In case you clone the repository, I'd suggest you to open them as a separate project.

## üì¨ Get the Plugin

You can find the plugin on either
the [Maven Central Repository](https://central.sonatype.com/artifact/io.github.emaarco/bpmn-to-code-maven)
or the [Gradle Plugin Portal](https://plugins.gradle.org/plugin/io.github.emaarco.bpmn-to-code-gradle)

## ü§ù Contributing

Community contributions are at the heart of bpmn-to-code‚Äôs vision.
If you have ideas to improve the code generation, want to add support for a new engine,
or are keen to help shape the styleguide validator,
please join me on [GitHub](https://github.com/example/bpmn-to-code).
Submit issues, open pull requests, or simply start a discussion.
